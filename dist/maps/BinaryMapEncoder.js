const fs=require("fs"),path=require("path"),zlib=require("zlib");class BinaryMapEncoder{static encodeToBinary(e){const t=Buffer.alloc(16);t.writeUInt32LE(e.width,0),t.writeUInt32LE(e.height,4),t.writeUInt32LE(e.tileSize,8),t.writeUInt32LE(0,12);const r=Buffer.alloc(e.width*e.height);if(Array.isArray(e.map)){let t=0;for(let o=0;o<e.height;o++)for(let n=0;n<e.width;n++)r[t++]=e.map[o][n]}else if(Array.isArray(e.encodedMap)){let t=0;for(let o=0;o<e.encodedMap.length;o+=2){const n=e.encodedMap[o],i=e.encodedMap[o+1];for(let e=0;e<i;e++)r[t++]=n}}let o=Buffer.alloc(0);if(e.teleporterCodes&&e.teleporterCodes.length>0){const t=Buffer.alloc(4);t.writeUInt32LE(e.teleporterCodes.length,0);const r=[];let n=4;for(const t of e.teleporterCodes){const e=Buffer.from(t.code,"utf8"),o=Buffer.alloc(4);o.writeUInt32LE(e.length,0);const i=Buffer.from(t.mapId||"","utf8"),s=Buffer.alloc(4);s.writeUInt32LE(i.length,0),r.push(o,e,s,i),n+=8+e.length+i.length}o=Buffer.concat([t,...r],n)}const n=Buffer.from(JSON.stringify(e.enemyConfig),"utf8"),i=Buffer.alloc(4);i.writeUInt32LE(n.length,0);const s=Buffer.concat([t,r,o,i,n]);return zlib.deflateSync(s)}static decodeFromBinary(e){const t=zlib.inflateSync(e),r=t.readUInt32LE(0),o=t.readUInt32LE(4),n=t.readUInt32LE(8),i=(t.readUInt32LE(12),r*o),s=t.slice(16,16+i),l=[];for(let e=0;e<o;e++){l[e]=[];for(let t=0;t<r;t++)l[e][t]=s[e*r+t]}let a=16+i,c=[];if(a<t.length){const e=t.readUInt32LE(a);a+=4;for(let r=0;r<e;r++){const e=t.readUInt32LE(a);a+=4;const r=t.slice(a,a+e).toString("utf8");a+=e;const o=t.readUInt32LE(a);a+=4;const n=t.slice(a,a+o).toString("utf8");a+=o,c.push({code:r,mapId:n})}}let d={};if(a<t.length){const e=t.readUInt32LE(a);if(a+=4,e>0){const r=t.slice(a,a+e).toString("utf8");try{d=JSON.parse(r)}catch(e){console.error("Failed to parse enemy config:",e)}}}return{width:r,height:o,tileSize:n,map:l,teleporterCodes:c,enemyConfig:d}}static saveBinaryMap(e,t){const r=this.encodeToBinary(e);return fs.writeFileSync(t,r),r.length}static loadBinaryMap(e){const t=fs.readFileSync(e);return this.decodeFromBinary(t)}static convertJsonMapsToBinary(e,t){fs.existsSync(t)||fs.mkdirSync(t,{recursive:!0});const r=fs.readdirSync(e).filter((e=>e.endsWith(".json"))),o=[];for(const n of r){const r=path.join(e,n),i=path.join(t,n.replace(".json",".bmap"));try{const e=JSON.parse(fs.readFileSync(r,"utf8")),t=this.saveBinaryMap(e,i),s=fs.statSync(r).size;o.push({file:n,jsonSize:s,binarySize:t,compressionRatio:(s/t).toFixed(2)})}catch(e){console.error(`Failed to convert ${n}:`,e)}}return o}static encodeForNetwork(e){const t={width:e.width,height:e.height,tileSize:e.tileSize,tiles:this._flattenTileArray(e.map||(e.encodedMap?require("./mapEncoder").decodeMap(e.encodedMap,e.width,e.height):[])),teleporterCodes:e.teleporterCodes||[],enemyConfig:e.enemyConfig};return console.log("Encoding network map with teleporters:",{hasTeleporterCodes:t.teleporterCodes&&t.teleporterCodes.length>0,teleporterCount:t.teleporterCodes?t.teleporterCodes.length:0}),zlib.deflateSync(JSON.stringify(t))}static decodeFromNetwork(e){const t=JSON.parse(zlib.inflateSync(e).toString("utf8"));return t.map=this._expandTileArray(t.tiles,t.width,t.height),delete t.tiles,t.teleporterCodes||(console.warn("Missing teleporter codes in network map data"),t.teleporterCodes=[]),console.log("Decoded network map:",{width:t.width,height:t.height,hasTeleporterCodes:t.teleporterCodes&&t.teleporterCodes.length>0,teleporterCount:t.teleporterCodes?t.teleporterCodes.length:0}),t}static _flattenTileArray(e){if(!e||!e.length)return[];const t=[];for(let r=0;r<e.length;r++)for(let o=0;o<e[r].length;o++)t.push(e[r][o]);return t}static _expandTileArray(e,t,r){const o=[];for(let n=0;n<r;n++){o[n]=[];for(let r=0;r<t;r++)o[n][r]=e[n*t+r]}return o}}module.exports=BinaryMapEncoder;